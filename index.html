<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>TinyReflectiveToolkit by TChatzigiannakis</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>TinyReflectiveToolkit</h1>
        <h2>Structural contracts, eager assembly loading, easier reflection.</h2>
        <a href="https://github.com/TChatzigiannakis/TinyReflectiveToolkit" class="button"><small>View project on</small> GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <p><strong>TinyReflectiveToolkit</strong> is a small C# library that offers some cool reflection-related facilities. It's still a very early version and a stable API is far, far away.</p>

<p>It is written and maintained by <a href="https://github.com/TChatzigiannakis"><strong>Theodoros Chatzigiannakis</strong></a>. It is distributed as free software, covered by the <a href="https://github.com/TChatzigiannakis/TinyReflectiveToolkit/blob/master/LICENSE"><strong>Mozilla Public License v2.0</strong></a>.</p>

<h2>
<a id="runtime-contracts-part-1-implementing-net-interfaces-at-runtime" class="anchor" href="#runtime-contracts-part-1-implementing-net-interfaces-at-runtime" aria-hidden="true"><span class="octicon octicon-link"></span></a>Runtime Contracts, Part 1: Implementing .NET interfaces at runtime</h2>

<p>When working with C# (or any other language with static and nominal typing), you may occasionally end up in a situation where <strong>you have two or more types that both expose one or more compatible methods:</strong></p>

<pre><code>public class UnrelatedType1 
{
    public int GetValue() { return 1; }
}

public class UnrelatedType2
{
    public int GetValue() { return 2; }
}
</code></pre>

<p>For some reason, <strong>you may want to put instances of these types in a common variable or collection</strong> and call <code>GetValue()</code> on them, <strong>but you can't</strong>, because they don't have a declared relationship that would allow the substitution you want:</p>

<pre><code>var values = new object[] 
{
   new UnrelatedType1(),
   new UnrelatedType2()
};
var sum = values.Sum(x =&gt; x.GetValue());      // no GetValue() member
</code></pre>

<p>Usually, the solution is to <strong>define an interface that you know they already implement in practice:</strong></p>

<pre><code>public interface IValue 
{
    int GetValue();
}
</code></pre>

<p>And then go ahead and add that interface to the list of interfaces these types implement. <strong>But often you can't do that because at least one of these types comes from a 3rd party library/framework</strong> and you don't have access to its code (or it may be impractical to change it and rebuild).</p>

<p>Most likely, you end up in the frustrating situation of having to use reflection or employ dynamic typing.</p>

<p><strong>Reflection</strong> has disadvantages:</p>

<ol>
<li>You have to cast the instances to a common supertype (like <code>object</code>) that's not useful for you and in the process <strong>you lose compile-time type safety</strong>.</li>
<li>
<strong>The call spots are ugly</strong>, in the sense that they are littered with <code>typeof</code>, <code>GetType()</code> and <code>Invoke</code> and possibly more casting and boxing.</li>
<li>
<strong>Member access using reflection is often slower</strong> than access through a statically typed expression (even if that call is a virtual call through an interface).</li>
</ol>

<p><strong>Dynamic typing</strong> has disadvantages:</p>

<ol>
<li>You have to use a dynamic variable and <strong>lose compile-time type safety</strong>.</li>
<li>When you're using a dynamic expression, <a href="https://www.youtube.com/watch?v=WWaLxFIVX1s"><strong>you lose IntelliSense!</strong></a>
</li>
<li>
<strong>Member access using dynamic expressions is often slower</strong> than access through a statically typed expression (as above).</li>
</ol>

<p>Using this very library, you have a third way to solve this problem - so <strong>don't throw away that type-safe interface</strong> you declared earlier! Find an object whose runtime type satisfies your interface, <strong>simply call <code>.ToContract&lt;T&gt;()</code></strong> where <code>T</code> is your interface and you're done!</p>

<p>With the example types declared above, this becomes:</p>

<pre><code>var values = new IValue[]
{
   new UnrelatedType1().ToContract&lt;IValue&gt;(),
   new UnrelatedType2().ToContract&lt;IValue&gt;() 
};
var sum = values.Sum(x =&gt; x.GetValue());
</code></pre>

<p><strong>And it works!</strong> </p>

<p>This techinque has some important advantages:</p>

<ol>
<li>
<strong>The syntax is clean</strong> and natural C#.</li>
<li>
<strong>IntelliSense doesn't go away at all</strong> and neither does type safety at the interface call spots.</li>
<li>When calling through the interface, <strong>the actual methods are stubs implemented using IL</strong> - the interface doesn't use reflection and lookups.</li>
<li>
<strong>It's extremely easy to use:</strong> just define your interface, call an extension method on those objects and let things take care of themselves automatically!</li>
</ol>

<p>Of course, it also has some disadvantages and limitations:</p>

<ol>
<li>The <code>ToContract&lt;T&gt;()</code> call can be expensive, because it uses reflection (to verify compatibility for each type/interface combination) and it emits IL dynamically to generate proxy types. However, this is largely mitigated by the fact that <strong>each type/interface combination is cached and existing proxy types are reused</strong> if they are applicable.</li>
<li>The <code>ToContract&lt;T&gt;()</code> call can only verify compatibility at runtime, not compile time.</li>
<li>The runtime type of the passed object must be declared public.</li>
<li>The interface <code>T</code> must also be public.</li>
</ol>

<h2>
<a id="runtime-contracts-part-2-covariance-and-contravariance-in-return-types-and-parameter-types" class="anchor" href="#runtime-contracts-part-2-covariance-and-contravariance-in-return-types-and-parameter-types" aria-hidden="true"><span class="octicon octicon-link"></span></a>Runtime Contracts, Part 2: Covariance and contravariance in return types and parameter types</h2>

<p>Consider the following class:</p>

<pre><code>public class MyClass
{
    public string Method(object arg)
    {
        return arg.ToString();
    }
}
</code></pre>

<p>And consider the following interface:</p>

<pre><code>public interface IObjectToString
{
    string Method(object arg);
}
</code></pre>

<p>It's easy to see why <code>MyClass</code> matches the constraints set by the <code>IObjectToString</code> interface. So you can legally declare <code>MyClass : IObjectToString</code>.</p>

<p>There are, however, other variations of this interface that the class doesn't seem to match:</p>

<pre><code>public interface IObjectToObject
{
    object Method(object arg);
}
public interface IStringToString
{
    string Method(string arg);
}
public interface IStringToObject
{
    object Method(string arg);
}
</code></pre>

<p>Indeed, any attempt to declare <code>MyClass : IObjectToObject</code> or <code>MyClass : IStringToString</code> or <code>MyClass : IStringToObject</code> is a compile-time error. This is how the C# language is. </p>

<p>But this is just a design decision or a limitation. It doesn't <em>have</em> to be like this. </p>

<p>If the interface requires that the method returns any kind of <code>object</code>, then a method that returns a <code>string</code> (which <em>is</em> a kind of <code>object</code>) actually satisfies the contract. In other words, <strong>return types could be covariant</strong> in inheritance scenarios.</p>

<p>Similarly, if an interface requires that a method takes a <code>string</code>, then a method that can take any <code>object</code> (including a <code>string</code>) actually satisfies the contract as well. In other words, <strong>parameter types could be contravariant</strong> in inheritance scenarios.</p>

<p>If you can see why this is so, then you'll be happy to know that <strong>this library supports covariance and contravariance</strong> (for method return types and parameter types respectively). In other words, the class shown above actually satisfies all four interfaces/contracts that were presented, using the <code>.Satisfies()</code> and <code>.ToContract()</code> extension methods.</p>

<p>The careful reader will notice that <strong>even where C# does support covariance and contravariance, it's applicable only for reference types</strong>. Or, with an example: an <code>IEnumerable&lt;string&gt;</code> is an <code>IEnumerable&lt;object&gt;</code> but an <code>IEnumerable&lt;int&gt;</code> isn't an <code>IEnumerable&lt;object&gt;</code>. This is because unboxed value types aren't proper <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov subtypes</a> of <code>object</code>.</p>

<p>This same careful reader will be happy to know that <strong>this library supports all of the above <em>even for value types</em></strong>. In other words, what we described above between <code>string</code> and <code>object</code> works the same between <code>int</code> and <code>object</code> as well.</p>

<h2>
<a id="runtime-contracts-part-3-binding-to-static-methods-and-operators" class="anchor" href="#runtime-contracts-part-3-binding-to-static-methods-and-operators" aria-hidden="true"><span class="octicon octicon-link"></span></a>Runtime Contracts, Part 3: Binding to static methods and operators</h2>

<p><strong>Normal .NET interfaces are designed to only declare instanced public properties and methods.</strong> This means that an interface can't describe the existence of static methods, operators, conversions, etc. This usually makes sense from a design viewpoint, but there are times when it limits the expressiveness of the constraints.</p>

<p><strong>The runtime contracts offered in this library</strong> are described as .NET interfaces, but they <strong>can bind to things like static methods and operators</strong>, using some attributes.</p>

<p>Example <strong>for static methods:</strong></p>

<pre><code>public interface IParsable
{
    [Static]
    object Parse(string s);
}
</code></pre>

<p>The <code>[Static]</code> attribute means that the candidate types must have a <code>static</code> method with that signature. If they do, then they satisfy this contract.</p>

<p>Therefore, <strong>instances of <code>bool</code>, <code>int</code>, <code>double</code> satisfy the <code>IParsable</code> contract.</strong></p>

<p>Whenever instances of these types are accessed through this contract, an instanced <code>Parse(string)</code> method will be available and it will polymorphically invoke the correct static method from that particular runtime type. (Because it binds to a static method, the instance is completely irrelevant - only the explicitly provided arguments are passed.)</p>

<p>Example <strong>for operators:</strong></p>

<pre><code>public interface ICastableTo&lt;T&gt;
{
    [Cast]
    T PerformCast();
}
</code></pre>

<p>The <code>[Cast]</code> attribute means that the candidate types are <em>not</em> required to implement a <code>PerformCast()</code> method. Instead, <strong>they are required to contain an explicit conversion operator</strong> to <code>T</code>. If they do, then they satisfy this contract. (The name of the decorated method is completely irrelevant.)</p>

<p>For example, <strong>instances of <code>int</code>, <code>float</code>, <code>double</code>, <code>decimal</code> satisfy the <code>ICastableTo&lt;int&gt;</code> contract</strong>.</p>

<p>With that out of the way, whenever instances of these types are accessed through this contract, a <code>PerformCast()</code> method will be available and it will polymorphically invoke the correct cast operator for the runtime type of the instance it is called on.</p>

<p>For binary operators, you can pick which side you want your current object on, like this:</p>

<pre><code>public interface ISubtractable
{
    [Subtraction(OpSide.ThisLeft)]
    int Subtract(int p);

    [Subtraction(OpSide.ThisRight)]
    int SubtractFrom(int p);
}
</code></pre>

<p>In this case, for a type <code>T</code>, <code>Subtract</code> binds to <code>operator- (T, int)</code> (<code>this</code> goes left) while <code>SubtractFrom</code> binds to <code>operator- (int, T)</code> (<code>this</code> goes right). There is currently no support for binary operators of the form <code>operator- (T, T)</code>.</p>

<h2>
<a id="assemblyloader-loading-dependencies-eagerly" class="anchor" href="#assemblyloader-loading-dependencies-eagerly" aria-hidden="true"><span class="octicon octicon-link"></span></a>AssemblyLoader: Loading dependencies eagerly</h2>

<p>By default, your runtime may be loading your application's dependencies lazily - that is, just before the first time you attempt to use them. This is good for applications that value short startup time and can handle small, distributed performance hits along the way.</p>

<p>But there are scenarios in which eager loading (even with a longer startup time) is <em>preferred</em> over incremental but possibly unpredictable lazy loading of dependencies. (A game is an example of an application that might fall into this category.)</p>

<p><strong>The <code>AssemblyLoader</code> class gives you the opportunity to eagerly load pending dependencies</strong> (and their dependencies, in turn) at any specified point. It's easy to use:</p>

<pre><code>new AssemblyLoader().LoadAllDependencies();
</code></pre>

<p><strong>It exposes events</strong> to which you can subscribe and be alerted between loading dependencies - it's great for (say) creating <em>informative</em> splash screens for your application!</p>

<pre><code>var loader = new AssemblyLoader();
loader.AssemblyLoading += (assembly) =&gt;
{
    Application.Invoke((a, b) =&gt; splash.LoadingText = assembly.Name);
    Task.Delay(1).Wait();
};
loader.LoadAllDependencies();
</code></pre>

<h2>
<a id="extension-methods-for-reflection-types-and-collections" class="anchor" href="#extension-methods-for-reflection-types-and-collections" aria-hidden="true"><span class="octicon octicon-link"></span></a>Extension methods for reflection types and collections</h2>

<p>Some built-in reflection-related methods aren't as easy to use as they could be. Some slightly more humane extension methods are offered, to make life a little bit easier:</p>

<p>Find all things with a specified attribute: </p>

<pre><code>var tests = allTypes.WithAttribute&lt;TestFixtureAttribute&gt;();
</code></pre>

<p>Effortlessly apply a filter <em>to that attribute</em>, while still returning the members you want: </p>

<pre><code>var thoseTests = allMethods
    .WithAttribute&lt;TestAttribute&gt;(x =&gt; x.Description == "That test");
</code></pre>

<p>...and more stuff will be added.</p>
        </section>

        <aside id="sidebar">
          <a href="https://github.com/TChatzigiannakis/TinyReflectiveToolkit/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/TChatzigiannakis/TinyReflectiveToolkit/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/TChatzigiannakis/TinyReflectiveToolkit"></a> is maintained by <a href="https://github.com/TChatzigiannakis">TChatzigiannakis</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>
