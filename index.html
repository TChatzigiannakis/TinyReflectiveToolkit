<!doctype html>
<!-- The Time Machine GitHub pages theme was designed and developed by Jon Rohan, on Feb 7, 2012. -->
<!-- Follow him for fun. http://twitter.com/jonrohan. Tail his code on http://github.com/jonrohan -->
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <link rel="stylesheet" href="stylesheets/stylesheet.css" media="screen">
  <link rel="stylesheet" href="stylesheets/pygment_trac.css">
  <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
  <script type="text/javascript" src="javascripts/script.js"></script>

  <title>TinyReflectiveToolkit</title>
  <meta name="description" content="A small library containing utilities related to reflection under the CLR.">

  <meta name="viewport" content="width=device-width,initial-scale=1">

</head>

<body>

  <div class="wrapper">
    <header>
      <h1 class="title">TinyReflectiveToolkit</h1>
    </header>
    <div id="container">
      <p class="tagline">A small library containing utilities related to reflection under the CLR.</p>
      <div id="main" role="main">
        <div class="download-bar">
        <div class="inner">
          <a href="https://github.com/TChatzigiannakis/TinyReflectiveToolkit/tarball/master" class="download-button tar"><span>Download</span></a>
          <a href="https://github.com/TChatzigiannakis/TinyReflectiveToolkit/zipball/master" class="download-button zip"><span>Download</span></a>
          <a href="https://github.com/TChatzigiannakis/TinyReflectiveToolkit" class="code">View TinyReflectiveToolkit on GitHub</a>
        </div>
        <span class="blc"></span><span class="trc"></span>
        </div>
        <article class="markdown-body">
          <p><strong>TinyReflectiveToolkit</strong> is a small CLR library that offers some cool reflection-related facilities. It's still a very early version - a stable API is far away.</p>

<p>It is written and maintained by <a href="https://github.com/TChatzigiannakis"><strong>Theodoros Chatzigiannakis</strong></a>.</p>

<p>It is distributed as free software, covered by the <a href="https://github.com/TChatzigiannakis/TinyReflectiveToolkit/blob/master/LICENSE"><strong>GNU GPLv3</strong></a>. If this is too restrictive for your needs and you would like to obtain it under different licensing terms, feel free to contact me.</p>

<h1>
<a name="highlights" class="anchor" href="#highlights"><span class="octicon octicon-link"></span></a>Highlights</h1>

<h2>
<a name="assemblyloader" class="anchor" href="#assemblyloader"><span class="octicon octicon-link"></span></a>AssemblyLoader</h2>

<p>By default, your runtime may be loading your application's dependencies lazily - that is, just before the first time you attempt to use them. This is good for applications that value short startup time and can handle small, distributed performance hits along the way.</p>

<p>But there are scenarios in which eager loading (even with a longer startup time) is <em>preferred</em> over incremental but possibly unpredictable lazy loading of dependencies. (A game is an example of an application that might fall into this category.)</p>

<p><strong>The <code>AssemblyLoader</code> class gives you the opportunity to eagerly load pending dependencies</strong> (and their dependencies, in turn) at any specified point.</p>

<p><strong>It works out of the box:</strong></p>

<pre><code>    new AssemblyLoader().LoadAllDependencies();
</code></pre>

<p><strong>It exposes events</strong> to which you can subscribe and be alerted between loading dependencies - it's great for (say) creating <em>informative</em> splash screens for your application!</p>

<pre><code>    var loader = new AssemblyLoader();
    loader.AssemblyLoading += (obj) =&gt;
    {
        Application.Invoke((a, b) =&gt; splash.LoadingText = obj.Name);
        Task.Delay(1).Wait();
    };
    loader.LoadAllDependencies();
</code></pre>

<h2>
<a name="runtime-contracts-implementing-net-interfaces-at-runtime" class="anchor" href="#runtime-contracts-implementing-net-interfaces-at-runtime"><span class="octicon octicon-link"></span></a>Runtime Contracts: Implementing .NET interfaces at runtime</h2>

<p>When working with C# (or any other language with static and nominal typing), you may occasionally end up in a situation where <strong>you have two or more types that both expose one or more compatible methods:</strong></p>

<pre><code>    public class UnrelatedType1 
    {
        public int GetValue() { return 1; }
    }

    public class UnrelatedType2
    {
        public int GetValue() { return 2; }
    }
</code></pre>

<p><strong>You want to put instances of these types in a common variable</strong> or collection and call <code>GetValue()</code> on them, <strong>but you can't</strong>, because they don't have a declared relationship that would allow the substitution you want:</p>

<pre><code>    var values = new IValue[] 
    {
       new UnrelatedType1(),          // this fails
       new UnrelatedType2()
    };
    var sum = values.Sum(x =&gt; x.GetValue());
</code></pre>

<p>Usually, the solution is to <strong>define an interface that you know they already implement in practice:</strong></p>

<pre><code>    public interface IValue 
    {
        int GetValue();
    }
</code></pre>

<p>And then go ahead and add that interface to the list of interfaces these types implement. <strong>But often you can't do that because at least one of these types comes from a 3rd party library/framework/component</strong> and you don't have access to its code (or it may be impractical to change it and rebuild).</p>

<p>Most likely, you end up in the frustrating situation of having to use reflection or employ dynamic typing.</p>

<p><strong>Reflection</strong> has disadvantages:</p>

<ol>
<li>You have to cast the instances to a common supertype (like <code>object</code>) that's not useful for you and in the process <strong>you lose compile-time type safety</strong>.</li>
<li>
<strong>The call spots are ugly</strong>, in the sense that they are littered with <code>typeof</code> and <code>Invoke</code> and even more casting and boxing.</li>
<li>
<strong>Member access using reflection is often slower</strong> than access through a statically typed expression (even if that call is a virtual call through an interface).</li>
</ol>

<p><strong>Dynamic typing</strong> has disadvantages:</p>

<ol>
<li>You have to use a dynamic variable and <strong>lose compile-time type safety</strong>.</li>
<li>When you're using a dynamic expression, <a href="https://www.youtube.com/watch?v=WWaLxFIVX1s"><strong>you lose IntelliSense!</strong></a>
</li>
<li>
<strong>Member access using dynamic expressions is often slower</strong> than access through a statically typed expression (as above).</li>
</ol>

<p>Using this very library, you have a third way to solve this problem - so <strong>don't throw away that type-safe interface</strong> you declared earlier! Just find an object whose runtime type satisfies your interface, <strong>simply call <code>.ToContract&lt;T&gt;()</code></strong> where <code>T</code> is your interface and you're done!</p>

<p>With the types declared as above, just do:</p>

<pre><code>    var values = new IValue[]
    {
       new UnrelatedType1().ToContract&lt;IValue&gt;(),
       new UnrelatedType2().ToContract&lt;IValue&gt;() 
    };
    var sum = values.Sum(x =&gt; x.GetValue());
</code></pre>

<p><strong>And it works!</strong> This techinque has some important advantages:</p>

<ol>
<li>
<strong>The syntax is clean</strong> and natural C#.</li>
<li>
<strong>IntelliSense doesn't go away at all</strong> and neither does type safety at the call spots.</li>
<li>When calling through the interface, <strong>the actual methods are stubs implemented using IL</strong> - not using reflection and lookups.</li>
<li>It's extremely easy to use.</li>
</ol>

<p>It also has disadvantages and limitations:</p>

<ol>
<li>The <code>ToContract&lt;T&gt;()</code> call can be expensive, because it uses reflection (to verify compatibility for each type/interface combination) and it emits IL dynamically to generate proxy types. However, this is largely mitigated by the fact that <strong>each type/interface combination is cached and existing proxies are reused</strong> if they are applicable.</li>
<li>The <code>ToContract&lt;T&gt;()</code> call can only verify compatibility at runtime, not compile time.</li>
<li>The runtime type of the passed object must be declared public.</li>
<li>The interface <code>T</code> must also be public.</li>
<li>Generic methods are not supported yet.</li>
</ol>

<h2>
<a name="extension-methods-for-reflection-types-and-collections" class="anchor" href="#extension-methods-for-reflection-types-and-collections"><span class="octicon octicon-link"></span></a>Extension methods for reflection types and collections</h2>

<p>Some built-in reflection-related methods aren't as easy to use as they could be. Some slightly more humane extension methods are offered, to make life a little bit easier:</p>

<p>Find all things with a specified attribute: </p>

<pre><code>    var tests = allTypes.WithAttribute&lt;TestFixtureAttribute&gt;();
</code></pre>

<p>Effortlessly apply a filter <em>to that attribute</em>, while still returning the members you want: </p>

<pre><code>    var thoseTests = allTypes
        .WithAttribute&lt;TestFixtureAttribute&gt;(x =&gt; x.Description == "That test");
</code></pre>

<p>...and more stuff will be added.</p>
        </article>
      </div>
    </div>
    <footer>
      <div class="owner">
      <p><a href="https://github.com/TChatzigiannakis" class="avatar"><img src="https://avatars1.githubusercontent.com/u/3066930?v=2&amp;s=60" width="48" height="48"></a> <a href="https://github.com/TChatzigiannakis">TChatzigiannakis</a> maintains <a href="https://github.com/TChatzigiannakis/TinyReflectiveToolkit">TinyReflectiveToolkit</a></p>


      </div>
      <div class="creds">
        <small>This page generated using <a href="http://pages.github.com/">GitHub Pages</a><br>theme by <a href="https://twitter.com/jonrohan/">Jon Rohan</a></small>
      </div>
    </footer>
  </div>
  <div class="current-section">
    <a href="#top">Scroll to top</a>
    <a href="https://github.com/TChatzigiannakis/TinyReflectiveToolkit/tarball/master" class="tar">tar</a><a href="https://github.com/TChatzigiannakis/TinyReflectiveToolkit/zipball/master" class="zip">zip</a><a href="" class="code">source code</a>
    <p class="name"></p>
  </div>

  
</body>
</html>
